\chapter{CoGhent Data and Link Traversal}
\label{chap:coghent_link_traversal}

The primary focus of this research is the development of tools for constructing queries that target specific properties of CoGhent Human-Made Objects. These queries can either be confined to data within the CoGhent LDESs or extend beyond them by employing Link Traversal to follow links and traverse the corresponding documents. This approach facilitates the acquisition of new insights into the CoGhent data by not only enhancing the understanding of specific Human-Made Objects but also enabling their comparison in novel ways.

In the subsequent sections of this research, Comunica's link traversal capabilities will be utilized, as its modularity allows for the creation of link traversal engines tailored to the structure of the CoGhent data and the specific needs of this research. However, it is important to note that link traversal, despite its potential, remains an active area of research and can be configured in various ways.

This chapter therefore aims to explore the use of link traversal for discovering properties of Human-Made Objects, starting from the CoGhent LDESs. The chapter begins by providing an overview of the available data sources that can serve as starting points for the link traversal process. It then delves into the development of a link traversal engine optimized for the objectives outlined above. Finally, the chapter examines the most pertinent and intriguing types of resources to which the CoGhent Human-Made Objects link. These resources will be crucial for achieving the goal of broadening the knowledge of the CoGhent data.

\section{CoGhent Data Sources}
\label{sec:coghent_data_sources}

CoGhent provides a set of LDESs for each participating institution. These LDESs are accessible through specific endpoints, as listed in Table~\ref{tab:ldes_endpoints}

\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \caption{CoGhent LDES endpoints as published by \citet{floreverk2022ldes}}
    \label{tab:ldes_endpoints}
    \begin{tabular}{ll}
        \toprule
        \multicolumn{1}{c}{Publishing organisation} & \multicolumn{1}{c}{Endpoint URI} \\
        \midrule
        Design Museum Gent (DMG) & \url{https://apidg.gent.be/opendata/adlib2eventstream/v1/dmg/objecten} \\
        Huis van Alijn (HVA) & \url{https://apidg.gent.be/opendata/adlib2eventstream/v1/hva/objecten} \\
        Industriemuseum & \url{https://apidg.gent.be/opendata/adlib2eventstream/v1/industriemuseum/objecten} \\
        STAM & \url{https://apidg.gent.be/opendata/adlib2eventstream/v1/stam/objecten} \\
        Archief Gent & \url{https://apidg.gent.be/opendata/adlib2eventstream/v1/archiefgent/objecten} \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{URI Redirection}

When accessing any of the URIs listed in Table~\ref{tab:ldes_endpoints}, it is resolved to the same URI but with an additional query parameter \linebreak\mintinline{text}{generatedAtTime}. For example, accessing the LDES from Industriemuseum results in the original URI being extended with \mintinline{text}{?generatedAtTime=2023-08-17T00:07:32.016Z}\footnote{Since the query parameter's value is time-dependent, this specific value serves only as an example of how it is structured.}.

This behavior is confirmed by running the following command:
\begin{center}
    {\small \mintinline{bash}{curl -i "https://apidg.gent.be/opendata/adlib2eventstream/v1/industriemuseum/objecten"}}
\end{center}
This returns an HTTP \mintinline{text}{302 Found} response code and a \mintinline{text}{Location} header with the extended URI, indicating a redirect to that link. Eventually, when a client (e.g. a browser or Comunica) sends a \mintinline{text}{GET} request to the updated link, the server returns the last (most recent) page of the requested LDES in JSON-LD format. \citep{mdn2023found302}

\subsection{Non-deterministic results}

When configuring a query engine, any or multiple of the CoGhent endpoints can be chosen as data sources, depending on the specific data of interest. Naturally, due to the nature of LDESs, the same query should never be assumed to yield the same results across multiple executions. However, even when running the same query multiple times in a row with the certainty that the LDES hasn't updated yet, the results will still differ in terms of content and order. This variability is attributed to the nature of LTQP and Comunica's implementation of it. After all, results are influenced by the order in which links are pushed to the link queue, which in turn is influenced by the time it takes for the corresponding HTTP requests to get resolved.

This phenomenon is demonstrated by running the query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image}\footnote{The query's specifics are discussed in Section~\ref{subsec:links_to_follow_manifest}.} twice, using Design Museum Gent's LDES as data source. Tables~\ref{tab:results_query_first_run} and~\ref{tab:results_query_second_run} show, for both executions respectively, each result's IIIF Manifest URI, as well as the order in which the results were returned. Comparing both outputs clearly proves the results from the two executions differ in both content and order.

\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
PREFIX iiif: <http://iiif.io/api/presentation/2#>
PREFIX cidoc:<http://www.cidoc-crm.org/cidoc-crm/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX w3-exif: <http://www.w3.org/2003/12/exif/ns#>
PREFIX w3-oa: <http://www.w3.org/ns/oa#>
SELECT ?manifest ?height ?image
WHERE {
  # Manifest URI
  ?human_made_object cidoc:P129i_is_subject_of ?manifest.
  # Image height
  ?manifest iiif:hasSequences/rdf:first/iiif:hasCanvases/rdf:first/w3-exif:height ?height.
  # Image URI
  ?canvas iiif:hasImageAnnotations/rdf:first/w3-oa:hasBody ?image.
}
LIMIT 10
    \end{minted}
    \caption{SPARQL query fetching ten Human-Made Object's IIIF Manifest URIs, image heights and image file URIs}
    \label{lst:sparql_manifest_height_image}
\end{listing}

\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \caption{(Part of) results after \textbf{first} execution of query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image}}
    \label{tab:results_query_first_run}
    \begin{tabular}{rl}
        \toprule
         & \multicolumn{1}{c}{IIIF Manifest URI} \\
        \midrule
        1 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:3086\_3-5 \\
        2 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:1992-0068 \\
        3 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:3130 \\
        4 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:1990-0051\_0-5 \\
        5 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:3054 \\
        6 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:3124 \\
        7 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0284 \\
        8 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0296 \\
        9 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0305 \\
        10 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0281\_21-21 \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \caption{(Part of) results after \textbf{second} execution of query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image}}
    \label{tab:results_query_second_run}
    \begin{tabular}{rl}
        \toprule
         & \multicolumn{1}{c}{IIIF Manifest URI} \\
        \midrule
        1 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:3075 \\
        2 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0305 \\
        3 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:3054 \\
        4 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:1563 \\
        5 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:1987-0447 \\
        6 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:1987-1127\_1-2 \\
        7 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0271 \\
        8 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0284 \\
        9 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2018-0296 \\
        10 & https://api.collectie.gent/iiif/presentation/v2/manifest/dmg:2990\_0-4 \\
        \bottomrule
    \end{tabular}
\end{table}

For similar reasons, the order in which CoGhent endpoint URIs are given to the engine as data sources does not necessarily imply that one endpoint's data has priority over the other. This is illustrated by running the same query (see Code Fragment~\ref{lst:sparql_manifest_height_image}) with the Design Museum Gent LDES first and the Huis Van Alijn LDES second, and then reversing the order. The results from both executions, as shown in Tables~\ref{tab:results_query_third_run} and~\ref{tab:results_query_fourth_run} respectively, once again show variations in content and order, yet most importantly don't seem to show any notable correlation to the order in which the endpoints were given to the engine.

\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \caption{(Part of) results after execution of query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image} with Design Museum Gent (\textbf{DMG}) LDES endpoint as \textbf{first} data source and Huis Van Alijn (\textbf{HVA}) LDES endpoint as \textbf{second} data source}
    \label{tab:results_query_third_run}
    \begin{tabular}{rl}
        \toprule
         & \multicolumn{1}{c}{IIIF Manifest URI} \\
        \midrule
        1 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-015 \\
        2 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2015-024-001 \\
        3 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:3223 \\
        4 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:3086\_3-5 \\
        5 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:1563 \\
        6 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-001 \\
        7 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:1987-1127\_2-2 \\
        8 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-002 \\
        9 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:1987-0447 \\
        10 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-003 \\
        \bottomrule
    \end{tabular}
\end{table}

\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \caption{(Part of) results after execution of query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image} with Huis Van Alijn (\textbf{HVA}) LDES endpoint as \textbf{first} data source and Design Museum Gent (\textbf{DMG}) LDES endpoint as \textbf{second} datasource}
    \label{tab:results_query_fourth_run}
    \begin{tabular}{rl}
        \toprule
         & \multicolumn{1}{c}{IIIF Manifest URI} \\
        \midrule
        1 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-002 \\
        2 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-001 \\
        3 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2014-031-003 \\
        4 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2009-018-568 \\
        5 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2009-018-568 \\
        6 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2015-024-004 \\
        7 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:2018-0261 \\
        8 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:2990\_4-4 \\
        9 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{dmg}:2018-0260 \\
        10 & https://api.collectie.gent/iiif/presentation/v2/manifest/\textbf{hva}:2015-024-001 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Duplicate Human-Made Objects}

It is also important to note that, since updates to an LDES object are performed by adding a new version of the object to the LDES, it is possible to receive multiple results for the same Human-Made Object. As discussed in Secion~\ref{sec:coghent_example_queries}, a potential workaround would be to use a combination of \mintinline{text}{distinct} and \mintinline{text}{order by} clauses in the query itself, to only retrieve the newest versions. However, since ordering can only occur when all results are in, this approach prevents them from appearing in a \textit{streaming} manner. A more efficient solution, therefore, is to let the application that initiated the query, keep track of Human-Made Object URIs while the results are coming in. That way, when the application encounters duplicate Human-Made Objects, it can decide to only retain the latest version's results. Since implementing such a solution is considered trivial, the issue will not be discussed further in this research.

\subsection{Conclusion}

In conclusion, the CoGhent LDES endpoints work perfectly well to initiate the Link Traversal-based Querying process from. Each institution having a separate LDES is an added bonus, as this gives users the flexibility to choose which institutions' data to query. However, it is essential to be aware that the results and order of results are not predictable due to the nature of LDESs as well as Comunica's LTQP implementation. Additionally, Human-Made Objects are spread over multiple pages in the LDES, which needs to be taken into consideration when building the Comunica link traversal engine configuration.

\section{Comunica Link Traversal Engine Configuration}
\label{sec:comunica_link_traversal_engine_configuration}

As discussed in Section~\ref{sec:comunica}, the Comunica engine offers a wide range of configurability for link traversal. Numerous link traversal-specific actors have been developed. Some of those have already matured, while others are still in active development. In this section, some of these actors will be considered for configuring a Comunica link traversal engine that meets the requirements of this research, as well as performs up to a standard that is acceptable for real-world use. The resulting configuration should ultimately determine the engine used throughout the rest of this research.

\subsection{Base Configuration}

The Comunica Link Traversal repository\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal}{https://github.com/comunica/comunica-feature-link-traversal}} already provides several predefined configurations\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/tree/master/engines/config-query-sparql-link-traversal/config}{https://github.com/comunica/comunica-feature-link-traversal/tree/master/engines/config-query-sparql-link-traversal/config}} that are \textit{out of the box} available to Comunica users to kick-start with LTQP. A common feature of these configurations is the initial import of \linebreak\mintinline{text}{config-base.json}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/blob/master/engines/config-query-sparql-link-traversal/config/config-base.json}{https://github.com/comunica/comunica-feature-link-traversal/blob/master/engines/config-query-sparql-link-traversal/config/config-base.json}}. This configuration file imports all actors and mediators necessary for the basic functionality of a Comunica Link Traversal engine, such as HTTP fetching, query operations, and RDF parsing. In other words, such a base configuration is essential to having a working link traversal engine. However, since this research does not focus on these basic functionalities, the intricacies of setting up a base configuration won't be discussed further. Rather, as is the case with the predefined configurations, the configuration specific to this research will also start with importing the \mintinline{text}{config-base.json} file.

\subsection{Basic Link Extractors}

The most important type of actors that should be considered when setting op a link traversal engine, are arguably the link extractors. When a new RDF document is encountered during the link traversal process, these actors determine which links from that document should be added to the link queue. In other words, they are the ones deciding which resources should be queried.

The most basic link extractor is the \textit{All Extract Links Actor}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-all}{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-all}}. This actor essentially implements the \textit{cAll} criterion, as discussed in Section~\ref{sec:ltqp}. Simply put, it adds all links it encounters to the link queue. However, this approach is not suitable for the purposes of this research, as it may lead to traversing too many documents that will most certainly not aid in resolving the query at hand, in turn leading to impractical execution times.

As already discussed, this research focuses on queries that fetch data specific to Human-Made Objects. This means that the specific paths to follow - starting from a Human-Made Object and ending in the object of interest - are known beforehand. In other words, the queries already specify these \textit{sequences of predicates}, allowing for a more targeted approach. Therefore, another interesting link extractor to consider, is the \textit{Quad Pattern Query Extract Links Actor}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-quad-pattern-query}{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-quad-pattern-query}}. Essentially, this actor is an implementation of the \textit{cMatch} criterion that was discussed in Section~\ref{sec:ltqp}. It adds only those links to the link queue that are part of quads that match at least one quad pattern in the query. Given the knowledge of the starting subject - Human-Made objects - and the specific sequence of predicates to follow, this actor should better \textit{guide} the engine in the right direction, leading to faster results. However, it is possible for certain documents to, by change, contain quads that don't lead to the data the query was set up for, still leading to \textit{wrong} documents being visited.

\subsection{Extracting Links based on Predicates}

Having in mind that sequences of predicates are already known beforehand, the most promising link extractor is the \textit{Predicates Extract Links Actor}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-predicates}{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-predicates}}. This type of link extractor was not discussed before, but its workings are straightforward. Essentially, for every quad in a document, the actor only considers objects. Apart from the object naturally needing to be a URI, the only links that are added to the link queue are those objects' links that have a predicate matching one of the regexes set in the actor's configuration. In other words, the sequences of predicates that define the queries considered in this research, can literally serve as the regexes this actor uses to evaluate predicates. Additionally, the \textit{rules} can even be tightened by obliging every quad's subject to match the URI of the document currently being processed. This extra requirement further narrows down the selection of links to follow, potentially speeding up the querying process even further.

To test this approach, a Comunica link traversal query engine is built using the configuration as depicted in Code Fragment~\ref{lst:config_predicates_actor}, in turn tasked with resolving the query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image}. Once again, the data source is set to the Design Museum Gent LDES endpoint. As can be seen in Code Fragment~\ref{lst:config_predicates_actor}, the configuration's second import is a custom configuration file. This file is displayed in Code Fragment~\ref{lst:actor_config_regexes_subject_true} and not only tasks the engine being built to use the Predicates Extract Links Actor, but also instructs this link actor to only consider object links whose predicates match the query's predicates and whose subjects match the current document's URI. The keys that specify these settings are respectively called \mintinline{text}{predicateRegexes} and \mintinline{text}{checkSubject}.

\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{json-ld}
{
  "@context": [
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/config-query-sparql/^2.0.0/components/context.jsonld",
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/config-query-sparql-link-traversal/^0.0.0/components/context.jsonld"
  ],
  "import": [
    "ccqslt:config/config-base.json",
    "./actors/extract-links-predicates-custom.json",
  ]
}
    \end{minted}
    \caption{Comunica link traversal engine configuration using Predicates Extract Links Actor}
    \label{lst:config_predicates_actor}
\end{listing}

\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small,breaklines]{json-ld}
{
  "@context": [
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/runner/^2.0.0/components/context.jsonld",
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/actor-extract-links-predicates/^0.0.0/components/context.jsonld"
  ],
  "@id": "urn:comunica:default:Runner",
  "@type": "Runner",
  "actors": [
    {
      "@id": "urn:comunica:default:extract-links/actors#predicates-common",
      "@type": "ActorExtractLinksPredicates",
      "checkSubject": true,
      "predicateRegexes": [
        "http://www.cidoc-crm.org/cidoc-crm/P129i_is_subject_of",
        "http://iiif.io/api/presentation/2#hasSequences",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        "http://iiif.io/api/presentation/2#hasCanvases",
        "http://www.w3.org/2003/12/exif/ns#height",
        "http://iiif.io/api/presentation/2#hasImageAnnotations",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        "http://www.w3.org/ns/oa#hasBody"
      ]
    }
  ]
}
    \end{minted}
    \caption{Comunica Predicates Extract Links Actor configuration with predicate regexes set to predicates from query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image} and subject checking \textbf{enabled}}
    \label{lst:actor_config_regexes_subject_true}
\end{listing}

However, after building the engine and instructing it to resolve the query, no results are returned. To uncover the reason for this failure, the logs\footnote{Logging can be enabled as explained here: \href{https://comunica.dev/docs/query/advanced/logging/}{https://comunica.dev/docs/query/advanced/logging/}.} outputted by the engine during execution and displayed in Code Fragment~\ref{lst:logs}, can be consulted. From these logs, it can be inferred that the engine initially fetches the provided data source, in this case, the Design Museum Gent LDES. Then, it retrieves the documents referenced in the context of the LDES in order to expand the LDES. Finally, once this expansion is completed successfully, the LDES is marked as \textit{identified}. As for the rest of the logs, there are no significant actions taking place. In other words, no other documents are identified, let alone requested. From this, it can be deduced that no links are being added to the link queue while traversing the LDES. This suggests that the configuration of the Predicates Extract Links Actor needs to be reviewed.

\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{text}
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             dmg/objecten
             { ... , method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
...
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             context/cultureel-erfgoed-object-ap.jsonld
             { ..., method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             context/persoon-basis.jsonld
             { ..., method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             context/cultureel-erfgoed-event-ap.jsonld
             { ..., method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             context/organisatie-basis.jsonld
             { ..., method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             context/generiek-basis.jsonld
             { ..., method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
[...]  INFO: Requesting
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             context/dossier.jsonld
             { ..., method: 'GET', actor: 'urn:comunica:default:http/actors#fetch' }
[...]  INFO: Identified as file source:
             https://apidg.gent.be/opendata/adlib2eventstream/v1/
             dmg/objecten?generatedAtTime=2023-08-12T00:01:27.217Z
             { actor: 'urn:comunica:default:rdf-resolve-hypermedia/actors#none' }
...
    \end{minted}
    \caption{(Cleaned up) logs outputted during execution of engine configured by files displayed in Code Fragments~\ref{lst:config_predicates_actor} and~\ref{lst:actor_config_regexes_subject_true}}
    \label{lst:logs}
\end{listing}

Through debugging, it can be determined that only two quads pass the test comparing their subject URIs to the URI of the current document, in this case the LDES. These quads in question are both TREE-related quads - as mentioned in Section~\ref{subsec:ldes}, LDESs are built on the TREE specification. It comes as no surprise that these quads fail the subsequent test that compares predicates with the provided regexes. However, the fact that only these two quads pass the first test, and every other quad fails, highlights why the configuration of the Predicates Extract Links Actor, as shown in Code Fragment~\ref{lst:actor_config_regexes_subject_true}, doesn't work for the query presented in Code Fragment \ref{lst:sparql_manifest_height_image}: since the \textit{starting point} of the query is expected to be a Human-Made Object subject - the first predicate \mintinline{text}{cidoc:P129i_is_subject_of} achieves this as only Human-Made Object subjects have this predicate in the LDES - these subjects will never match the URI of the LDES. As a result, the Predicates Extract Links Actor will disregard these quads.

One possible solution is to modify the query by providing the LDES page itself as the \textit{starting point} and extending the sequence of predicates to \textit{ bridge the gap} between the LDES root node and the Human-Made Objects. However, as part of the aim of this research is to assist people without a technical background in constructing and better comprehending queries, making the queries unnecessarily long and complex is not desirable. Consequently, the decision is made to set the \mintinline{text}{checkSubject} key in the configuration of the Predicates Extract Links Actor to \mintinline{text}{false}. This ultimately leads to the configuration presented in Code Fragment~\ref{lst:actor_config_regexes_subject_false}.

\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small,breaklines]{json-ld}
{
  "@context": [
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/runner/^2.0.0/components/context.jsonld",
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/actor-extract-links-predicates/^0.0.0/components/context.jsonld"
  ],
  "@id": "urn:comunica:default:Runner",
  "@type": "Runner",
  "actors": [
    {
      "@id": "urn:comunica:default:extract-links/actors#predicates-common",
      "@type": "ActorExtractLinksPredicates",
      "checkSubject": false,
      "predicateRegexes": [
        "http://www.cidoc-crm.org/cidoc-crm/P129i_is_subject_of",
        "http://iiif.io/api/presentation/2#hasSequences",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        "http://iiif.io/api/presentation/2#hasCanvases",
        "http://www.w3.org/2003/12/exif/ns#height",
        "http://iiif.io/api/presentation/2#hasImageAnnotations",
        "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
        "http://www.w3.org/ns/oa#hasBody"
      ]
    }
  ]
}
    \end{minted}
    \caption{Comunica Predicates Extract Links Actor configuration with predicate regexes set to predicates from query displayed in Code Fragment~\ref{lst:sparql_manifest_height_image} and subject checking \textbf{disabled}}
    \label{lst:actor_config_regexes_subject_false}
\end{listing}

\subsection{Comparing Link Extractors}

In an attempt to compare the discussed link extractors not only in terms of functionality but also in terms of performance, a small experiment is conducted. Similar to before, the query shown in Code Fragment~\ref{lst:sparql_manifest_height_image} is used, with the Design Museum Gent LDES serving as the data source. The first engine utilizes the All Extract Links Actor, the second one employs the Predicates Extract Links Actor, and the third utilizes the Predicates Extract Links Actor in the configuration outlined in Code Fragment~\ref{lst:actor_config_regexes_subject_false}. Consequently, the final engine configurations corresponded to the existing \textit{Follow All}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/blob/master/engines/config-query-sparql-link-traversal/config/config-follow-all.json}{https://github.com/comunica/comunica-feature-link-traversal/blob/master/engines/config-query-sparql-link-traversal/config/config-follow-all.json}} and \textit{Follow Match Query}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/blob/master/engines/config-query-sparql-link-traversal/config/config-follow-match-query.json}{https://github.com/comunica/comunica-feature-link-traversal/blob/master/engines/config-query-sparql-link-traversal/config/config-follow-match-query.json}} configurations present in the Comunica Link Traversal GitHub repository, along with the custom configuration as illustrated in Code Fragment~\ref{lst:config_predicates_actor}. To ensure reliability, each engine executes the query consecutively three times, with the engine's complete HTTP cache being invalidated after each run. The outcomes of the experiment are presented in Table~\ref{tab:results_engines}.

\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \caption{Results from experiment comparing different Comunica link traversal engines}
    \label{tab:results_engines}
    \begin{tabular}{lrr}
        \toprule
        \multicolumn{1}{c}{Engine} & \multicolumn{1}{c}{Total time (s)} & \multicolumn{1}{c}{Average time single execution (s)} \\
        \midrule
        Follow All & Runtime error & Runtime error \\
        Follow Match Query & 66.08 & 22.03 \\
        Custom (using configuration displayed in Code Fragment \ref{lst:actor_config_regexes_subject_false}) & 54.34 & 18.11 \\
        \bottomrule
    \end{tabular}
\end{table}

The results immediately indicate that the Follow All engine struggles to execute the query successfully. It is important to note that the success rate is subject to a variety of factors, encompassing both client and server circumstances, such as the machine's specifications and the state of the internet connection. However, in this specific instance, the runtime error that emerged following unsuccessful link traversal was attributed to an excessive number of listeners assigned to a TLS socket. This situation may be associated with an overflow of HTTP requests. The combination of this issue with the absence of any valid results even after a considerable time span underscores that, for the objectives of this research, the Follow All engine, without additional configuration or the integration of supplementary actors, is unsuitable.

Fortunately, both the Follow Match Query and Custom engines were able to successfully execute their tasks. It is noteworthy, however, that the average times to resolve the query differ by only a few seconds. As expected, the custom engine performs better, but the marginal time saved initially might not seem significant compared to the drawback of having to adjust its configuration for each query. Nevertheless, it is reasonable to expect that the custom engine's advantage will become more pronounced when handling queries that target data distributed across multiple documents and situated at deeper levels. Moreover, it is entirely feasible to develop a user-friendly application that constructs the necessary configuration based on the specific query before executing the engine. This way, the configuration complexity can be abstracted from the end-users, providing a smoother user experience while harnessing the benefits of the custom engine's efficiency.

\subsection{Traversing LDES Pages}

Despite the custom engine's capacity to retrieve highly targeted data, its present form only accounts for a fraction of the available dataset. This limitation arises from the fact that an LDES comprises multiple pages, technically TREE nodes, necessitating both forward and backward \textit{browsing} to encompass the entirety of the dataset. However, the predicates leading to the objects providing access to these other TREE nodes are presently absent from the regex array in the configuration of the Predicates Extract Links Actor.

While incorporating these predicates is straightforward, an even more effective approach involves introducing a second link extractor to the custom engine configuration. The \textit{Extract Links Tree Actor}\footnote{\href{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-extract-tree}{https://github.com/comunica/comunica-feature-link-traversal/tree/master/packages/actor-extract-links-extract-tree}} possesses the capability to introduce links to the preceding and succeeding LDES \textit{pages} – as identified by the \textit{greater than} and \textit{less than} relationships as defined within the TREE specification – into the link queue. This modest addition to the configuration profoundly enhances the capabilities of the resultant engine.

The revised configuration, as presented in Code Fragment~\ref{lst:config_predicates_actor_tree}, not only facilitates finely targeted searches for the requested data but also encompasses the complete dataset of the specified CoGhent institution(s) by leveraging the Extract Links Tree Actor.

\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{json-ld}
{
  "@context": [
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/config-query-sparql/^2.0.0/components/context.jsonld",
    "https://linkedsoftwaredependencies.org/bundles/npm/
        @comunica/config-query-sparql-link-traversal/^0.0.0/components/context.jsonld"
  ],
  "import": [
    "ccqslt:config/config-base.json",
    "./actors/extract-links-predicates-custom.json",
    "ccqslt:config/extract-links/actors/tree.json",
  ]
}
    \end{minted}
    \caption{Comunica link traversal engine configuration using Predicates Extract Links Actor and Extract Links Tree Actor}
    \label{lst:config_predicates_actor_tree}
\end{listing}

\subsection{Conclusion}

In summary, an engine constructed using the Follow Match Query configuration, which utilizes the Quad Pattern Query Extract Links Actor, effectively addresses specific query requirements without necessitating additional actor configuration. However, for queries demanding more extensive traversal across documents or encompassing data distributed across multiple documents, a tailored configuration that integrates both the Predicates Extract Links Actor and the Extract Links Tree Actor can significantly enhance performance. 

It is important to acknowledge that this approach does require a specific configuration outlining the predicates for each query. Nevertheless, this configuration complexity can be effectively abstracted from end-users through the development of tools that manage the technical intricacies behind the scenes. This approach ultimately strikes a balance between query performance optimization and user accessibility, aligning with the overarching goals of the research.

\section{Links to Follow}
\label{sec:links_to_follow}

TODO

\subsection{IIIF Manifest}
\label{subsec:links_to_follow_manifest}

TODO

\subsection{Wikidata}

TODO

\subsection{Stad Gent}

TODO

\subsection{Getty Vocabularies}

TODO

\section{Conclusion}
\label{sec:coghent_link_traversal_conclusion}