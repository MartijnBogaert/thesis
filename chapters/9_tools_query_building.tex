\chapter{Tools for Query Building}
\label{chap:tools_query_building}

Discovering digital art collections encompasses a wide array of possibilities, each with its unique interpretations and implementations. This research, however, primarily centers on the facilitation aspect of this discovery process. The CoGhent collections undoubtedly harbor a treasure trove of potentially captivating insights, yet professionals and art enthusiasts can only unlock these treasures if they can formulate the right SPARQL queries. This task is far from simple, particularly when considering that these individuals might lack the technical proficiency required to construct such queries. Consequently, this chapter introduces and partially develops two conceptual web applications designed to significantly alleviate the technical complexities of query formulation for users.

The first application draws inspiration from the existing CoGhent Query Builder proposed in Section~\ref{subsec:coghent_query_builder}. The fundamental concept remains unchanged: users are presented with a list of properties, and based on their selections, the application constructs a query with the necessary triple patterns to retrieve the desired data. However, the \textit{enhanced} iteration of this application takes two further strides. Firstly, it introduces modularity by ensuring that the properties and their corresponding triple patterns are not hard-coded into the application. Instead, they are provided as sequences of predicates through JSON files. Secondly, the application supports the generation of \textit{cross-dataset queries} that can be effectively resolved through a link traversal engine, as elaborated in Chapter~\ref{chap:coghent_link_traversal}.

The second application targets users with a slightly more advanced understanding of RDF. It empowers them to explore the predicate sequences of properties of interest themselves. This exploration journey begins with an RDF resource provided by the user. From this initial \textit{root} resource, users can progressively construct a tree comprising of predicates and objects. Based on users' choices, the application executes queries to fetch the predicates and objects associated with an already-present resource in the tree. As users gain a deeper understanding of the data accessible through the given root resource, they can select specific objects within the tree. The application then deduces the predicate sequences leading from the root resource to these chosen objects and subsequently generates a corresponding query. Crucially, since this query solely relies on predicate sequences, it empowers users to perform a generalized inquiry on their entire dataset(s), not just the resource specified at the beginning of the process.

Both of these applications are briefly introduced in Sections~\ref{sec:new_query_builder} and~\ref{sec:discovering_predicate_sequences}, respectively, by discussing their main features and most essential implementation details. For the complete implementations, readers are referred to their respective GitHub repositories: \url{https://github.com/thesis-Martijn-Bogaert-2022-2023/sparql-query-builder-ui} and \url{https://github.com/thesis-Martijn-Bogaert-2022-2023/rdf-predicates-explorer}. However, prior to this, Section~\ref{sec:building_queries_predicate_sequences} first covers the fundamental functionality shared by both web applications. As to avoid repeating code and to ensure separation of concerns, this functionality lives on its own and is incorporated into the other two applications by importing its implementation as a package. The detailed implementation of this essential tool can be found in the following GitHub repository: \url{https://github.com/thesis-Martijn-Bogaert-2022-2023/sparql-query-builder}.

\section{Building Queries from Predicate Sequences}
\label{sec:building_queries_predicate_sequences}

TODO

\subsection{Arrays of Triple Patterns}

TODO

% Easiest way to rebuild existing app:
%
% - Keep dict of properties (e.g. title, description ...) and their necessary statements for WHERE clause
%   E.g.:
%   title: '?o cidoc:P102_has_title ?title.'
%   OR for properties needing more than one statement
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{js}
objectname: [
    '?s cidoc:P41i_was_classified_by ?classified.',
    '?classified cidoc:P42_assigned ?assigned.',
    '?assigned skos:prefLabel ?objectname.',
]
    \end{minted}
    \caption{WHERE clause statements to query for \textit{objectname} stored as elements in array}
    \label{lst:where_statements_array}
\end{listing}
%   Above can also be saved as one single string
%
% - Always add all prefixes at top of query:
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
PREFIX cidoc:<http://www.cidoc-crm.org/cidoc-crm/>
PREFIX adms:<http://www.w3.org/ns/adms#>
PREFIX skos:<http://www.w3.org/2004/02/skos/core#>
PREFIX la:<https://linked.art/ns/terms/>
    \end{minted}
    \caption{All possible PREFIX statements of original CoGhent Query Builder}
    \label{lst:prefix_statements_original}
\end{listing}
%
% Downsides: WHERE clause statements very much hardcoded + hardcoded prefixes not good for modularity app

\subsection{Arrays of Predicates}

TODO

% Other idea:
%
% in fact, only predicates are important -> save only those
% together with predicate, save prefix
% E.g.:
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{js}
objectname: [
    { prefix: 'cidoc', predicate: 'P41i_was_classified_by' },
    { prefix: 'cidoc', predicate: 'P42_assigned' },
    { prefix: 'skos', predicate: 'prefLabel' },
]
    \end{minted}
    \caption{Prefixes and predicates for WHERE clause statements to query for \textit{objectname} stored as elements in array}
    \label{lst:where_statements_array_predicates}
\end{listing}
%
% Downsides:
% - app needs to come up with variable names itself
%   e.g.
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
# Objectname
?s cidoc:P41i_was_classified_by ?var1.
?var1 cidoc:P42_assigned ?var2.
?var2 skos:prefLabel ?o3.
    \end{minted}
    \caption{WHERE clause statements with object variable names constructed using numbers}
    \label{lst:where_statements_objects_numbers}
\end{listing}
%   OR
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
# Objectname
?s
    cidoc:P41i_was_classified_by
        ?s_cidoc_P41i_was_classified_by.
?s_cidoc_P41i_was_classified_by
    cidoc:P42_assigned
        ?s_cidoc_P41i_was_classified_by_cidoc_P42_assigned.
?s_cidoc_P41i_was_classified_by_cidoc_P42_assigned
    skos:prefLabel
        ?s_cidoc_P41i_was_classified_by_cidoc_P42_assigned_skos_prefLabel.
    \end{minted}
    \caption{WHERE clause statements with object variable names constructed from preceding statements}
    \label{lst:where_statements_objects_long}
\end{listing}
%   -> both very unreadable
%   -> query builder not only to help build queries but also to help understand queries and data
%   -> better to have readable variables (proposed by humans up front) OR use no variables (property path sequence)
%
% Upside: keeping track of "bare" predicates one by one can help "clean up" query later on when start statements might overlap
% E.g.:
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
# Place
?o cidoc:P108i_was_produced_by ?produced.
?produced cidoc:P7_took_place_at ?tookplace.
?tookplace la:equivalent ?plaatsequivalent.
?plaatsequivalent skos:prefLabel ?plaats.
# Date
?produced cidoc:P4_has_time-span ?timespan.
    \end{minted}
    \caption{WHERE clause statements without overlapping statements}
    \label{lst:where_statements_no_overlapping}
\end{listing}
% instead of
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
# Place
?o cidoc:P108i_was_produced_by ?produced.
?produced cidoc:P7_took_place_at ?tookplace.
?tookplace la:equivalent ?plaatsequivalent.
?plaatsequivalent skos:prefLabel ?plaats.
# Date
?o cidoc:P108i_was_produced_by ?produced.
?produced cidoc:P4_has_time-span ?timespan.
    \end{minted}
    \caption{WHERE clause statements with overlapping statements}
    \label{lst:where_statements_overlapping}
\end{listing}
% Might make a difference in length of query when more statements overlap, but when the query is run, Comunica will "clean things up" for us, so doesn't have influence on data retrieval (TODO: check if true)
% To keep queries readable & app not too complicated -> let's not worry about such "feature"

\subsection{User-Defined Variable Names and Property Path Sequences}

TODO

% Compromise:
%
% app expects dict with properties (keys) and corresponding necessary statements (values)
% as seen before, values are arrays containing objects
% each object will be mapped to a triple (or will be part of property path sequence) in the WHERE clause, and:
% - must have predicate ('predicate')
% - may have prefix (for predicate) ('prefix')
% - may have variable name for predicate's object ('object_variable_name')
%   in case not present, construct property path sequence (no need for object variable names)
%
% dict with necessary prefixes mapped to uri's also fed to app
%
% An example:
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{js}
const properties = {
    title: [
        { prefix: 'cidoc', predicate: 'P102_has_title' }
    ],
    description: [
        { prefix: 'cidoc', predicate: 'P3_has_note', object_variable_name: 'note' },
    ],
    objectname: [
        { prefix: 'cidoc', predicate: 'P41i_was_classified_by' },
        { prefix: 'cidoc', predicate: 'P42_assigned' },
        { prefix: 'skos', predicate: 'prefLabel' },
    ],
    association: [
        { prefix: 'cidoc', predicate: 'P128_carries' },
        { prefix: 'cidoc', predicate: 'P129_is_about', object_variable_name: 'about' },
        { prefix: 'cidoc', predicate: 'P2_has_type' },
        { prefix: 'skos', predicate: 'prefLabel' },
    ],
};

const prefixes = {
    cidoc: 'http://www.cidoc-crm.org/cidoc-crm/',
    skos: 'http://www.w3.org/2004/02/skos/core#',
};
    \end{minted}
    \caption{Properties and prefixes ready to be consumed by query building function}
    \label{lst:properties_prefixes_query_build_function}
\end{listing}
% results in (title has no object var name, description has, objectname hasn't -> property path sequence, assocation has both)
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
PREFIX cidoc:<http://www.cidoc-crm.org/cidoc-crm/>
PREFIX skos:<http://www.w3.org/2004/02/skos/core#>

SELECT ?title ?note ?objectname ?association

WHERE {
    # title
    ?human_made_object cidoc:P102_has_title ?title.
    
    # description
    ?human_made_object cidoc:P3_has_note ?note.
    
    # objectname
    ?human_made_object
        cidoc:P41i_was_classified_by/cidoc:P42_assigned/skos:prefLabel
            ?objectname.
    
    # association
    ?human_made_object cidoc:P128_carries/cidoc:P129_is_about ?about.
    ?about cidoc:P2_has_type/skos:prefLabel ?association.
}
    \end{minted}
    \caption{SPARQL query generated from input displayed in Code Fragment \ref{lst:properties_prefixes_query_build_function}}
    \label{lst:query_generated_edge_cases}
\end{listing}

\subsection{Filtered and Optional Properties}

TODO

% FILTER
% possible to create extra dict with property names as keys and filter details as values and feed to app
% but having too many dicts becomes little chaotic
% better to extend original propeties dict so it can house extra information (like filter details) apart from statements
%
% original app: only filter using string values
% this version: make multiple types of filter possible
% e.g. give string for string filtering (regex, case insensitive) + give language for language filtering
% app functionality can easily be extended for more filter types

% OPTIONAL
% extend original app functionality with optional properties
% in properties dict: 'optional' (key) - boolean (value)

% EXAMPLE with filter & optional
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{js}
const properties = {
    title: {
        statements: [
            { prefix: 'cidoc', predicate: 'P102_has_title' }
        ],
    },
    description: {
        statements: [
            { prefix: 'cidoc', predicate: 'P3_has_note', object_variable_name: 'note' },
        ],
        filters: { string: 'luchter', language: 'nl' },
        optional: true,
    },
};
    \end{minted}
    \caption{Example of properties dictionary to illustrate use of filters and optionals}
    \label{lst:properties_filter_optionals}
\end{listing}
% results in (note filters and optional keys)
\begin{listing}[htbp]
    \begin{minted}[samepage,fontsize=\small]{sparql}
PREFIX cidoc:<http://www.cidoc-crm.org/cidoc-crm/>

SELECT ?title ?note

WHERE {
    # title
    ?human_made_object cidoc:P102_has_title ?title.
    
    # description
    OPTIONAL {
        ?human_made_object cidoc:P3_has_note ?note.
        
        FILTER(REGEX(?note, "luchter", "i"))
        FILTER(LANG(?note) = "nl")
    }
}
    \end{minted}
    \caption{SPARQL query generated from input displayed in Code Fragment \ref{lst:properties_filter_optionals}}
    \label{lst:query_generated_filters_optionals}
\end{listing}

\subsection{Limit and Offset}

TODO

% LIMIT and OFFSET
% according to coghent documentation "the SparQL endpoint limits results to 1.000 lines." (https://coghent.github.io/basicqueries.html), but Cominica gives more by default: 10.000 -> what's up with this (TODO: ask)
% in app, just feed to query building function as arguments


\section{A New Query Builder}
\label{sec:new_query_builder}

TODO

\subsection{Modularity}

TODO

\subsection{Performing Queries}

TODO

\section{Discovering Predicate Sequences}
\label{sec:discovering_predicate_sequences}

TODO

\subsection{Starting Resource}

TODO

\subsection{Tree Data Structure and Visualization}

TODO

\subsection{Tree Expansion}

TODO

\subsection{Predicate Sequences Selection}

TODO

\subsection{Performing Queries}

TODO

\section{Conclusion}

TODO